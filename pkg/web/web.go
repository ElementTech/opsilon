package web

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strings"

	"github.com/jatalocks/opsilon/internal/concurrency"
	"github.com/jatalocks/opsilon/internal/config"
	"github.com/jatalocks/opsilon/internal/db"
	"github.com/jatalocks/opsilon/internal/get"
	"github.com/jatalocks/opsilon/internal/internaltypes"
	"github.com/jatalocks/opsilon/pkg/repo"
	"github.com/jatalocks/opsilon/pkg/run"
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	"github.com/pangpanglabs/echoswagger/v2"
	"go.mongodb.org/mongo-driver/bson"
)

var ver string

func App(port int64, v string) {
	ver = v
	// Echo instance
	e := echoswagger.New(echo.New(), "/api/v1/docs", &echoswagger.Info{
		Title:       "Opsilon API",
		Description: "This API interface allows for interaction with Opsilon's components the same way CLI does.",
		Version:     ver,
		License: &echoswagger.License{
			Name: "GNU GPLv3",
			URL:  "https://spdx.org/licenses/GPL-3.0-or-later.html",
		},
	}).
		SetResponseContentType("application/json").
		SetScheme("https", "http").
		SetUI(echoswagger.UISetting{DetachSpec: true, HideTop: true})

	// Middleware
	e.Echo().Use(middleware.Logger())
	e.Echo().Use(middleware.Recover())
	// Routes
	e.GET("/api/v1/version", version).
		AddResponse(http.StatusOK, "the opsilon binary version", nil, nil)
	e.GET("/api/v1/list", list).
		AddResponse(http.StatusOK, "list of available workflows", nil, nil).
		AddParamQuery("", "repos", "comma seperated list of repositories", false)

	rg := e.Group("repo", "/api/v1/repo")
	rg.GET("/list", rlist).
		AddResponse(http.StatusOK, "list of added repositories", nil, nil)
	rg.POST("/add", radd).
		AddResponse(http.StatusCreated, "add a repository", nil, nil).
		AddParamBody(config.Repo{}, "repo", "repository to add", true)
	rg.DELETE("/delete/:repo", rdelete).
		AddResponse(http.StatusOK, "delete a repository", nil, nil).
		AddParamPath("", "repo", "repository to delete")

	rgw := e.Group("workflow", "/api/v1/workflow")
	rgw.GET("/list", wlist).
		AddResponse(http.StatusOK, "list workflows that have been run by this server", nil, nil).
		AddParamQuery("", "workflow", "workflow id to view (generated by hashing the workflow), omit to view all", false)
	rgw.DELETE("/delete/:workflow", rgdelete).
		AddResponse(http.StatusOK, "delete a workflow", nil, nil).
		AddParamPath("", "workflow", "workflow to delete")

	rrgw := e.Group("run", "/api/v1/run")
	rrgw.GET("/list", wrlist).
		AddResponse(http.StatusOK, "list runs of a certain workflow", nil, nil).
		AddParamQuery("", "workflow", "workflow id to view (generated by hashing the workflow), omit to view all", false)
	rrgw.DELETE("/delete/:run", rrdelete).
		AddResponse(http.StatusOK, "delete a run", nil, nil).
		AddParamPath("", "run", "run to delete")

	e.POST("/api/v1/run", wrun).
		AddResponse(http.StatusOK, "run a workflow", nil, nil).
		AddParamBody(internaltypes.WorkflowArgument{}, "workflow", "workflow to run", true)
	// e.GET("/api/v1/swagger/*", echoSwagger.WrapHandler)
	// Start server
	e.Echo().Logger.Fatal(e.Echo().Start(":" + fmt.Sprint(port)))
}

func version(c echo.Context) error {
	return c.String(http.StatusOK, ver)
}

// Handler
func list(c echo.Context) error {
	repos := c.QueryParam("repos")
	r := []string{}
	if repos != "" {
		r = strings.Split(repos, ",")
	}
	w, err := get.GetWorkflowsForRepo(r)

	if err != nil {
		return c.String(http.StatusInternalServerError, err.Error())
	} else {
		e, err := json.Marshal(w)
		if err != nil {
			return c.String(http.StatusInternalServerError, err.Error())
		}
		return c.JSONBlob(http.StatusOK, e)
	}
}

// Handler
func wlist(c echo.Context) error {
	workflow := c.QueryParam("workflow")
	filter := bson.D{}
	if workflow != "" {
		filter = bson.D{{Key: "workflow", Value: workflow}}
	}
	docs, err := db.FindMany("workflows", filter)

	if err != nil {
		return c.String(http.StatusInternalServerError, err.Error())
	} else {
		e, err := json.Marshal(docs)
		if err != nil {
			return c.String(http.StatusInternalServerError, err.Error())
		}
		return c.JSONBlob(http.StatusOK, e)
	}
}

// Handler
func wrlist(c echo.Context) error {
	workflow := c.QueryParam("workflow")
	filter := bson.D{}
	if workflow != "" {
		filter = bson.D{{Key: "workflow", Value: workflow}}
	}
	docs, err := db.FindMany("results", filter)
	if err != nil {
		return c.String(http.StatusInternalServerError, err.Error())
	} else {
		e, err := json.Marshal(docs)
		if err != nil {
			return c.String(http.StatusInternalServerError, err.Error())
		}
		return c.JSONBlob(http.StatusOK, e)
	}
}

// Handler
func rlist(c echo.Context) error {
	e, err := json.Marshal(config.GetConfig())
	if err != nil {
		return c.String(http.StatusInternalServerError, err.Error())
	}
	return c.JSONBlob(http.StatusOK, e)
}
func radd(c echo.Context) error {
	u := new(config.Repo)
	if err := c.Bind(u); err != nil {
		return c.String(http.StatusBadRequest, err.Error())
	}
	if err := repo.InsertRepositoryIfValid(*u); err != nil {
		return c.String(http.StatusBadRequest, err.Error())
	}
	return c.JSON(http.StatusCreated, u)
}

func rdelete(c echo.Context) error {
	repository := c.Param("repo")
	if err := repo.Delete([]string{repository}); err != nil {
		return c.String(http.StatusBadRequest, err.Error())
	}
	return c.String(http.StatusOK, repository)
}
func rgdelete(c echo.Context) error {
	workflow := c.Param("workflow")
	err := db.DeleteOne("workflows", bson.D{{Key: "_id", Value: workflow}})
	if err != nil {
		return c.String(http.StatusInternalServerError, err.Error())
	} else {
		return c.String(http.StatusOK, workflow)
	}
}

func rrdelete(c echo.Context) error {
	run := c.Param("run")
	err := db.DeleteOne("results", bson.D{{Key: "_id", Value: run}})
	if err != nil {
		return c.String(http.StatusInternalServerError, err.Error())
	} else {
		return c.String(http.StatusOK, run)
	}
}

func wrun(c echo.Context) error {
	u := new(internaltypes.WorkflowArgument)
	if err := c.Bind(u); err != nil {
		return c.String(http.StatusBadRequest, err.Error())
	}
	missing, chosenAct := run.ValidateWorkflowArgs(u.Repo, u.Workflow, u.Args)
	if len(missing) > 0 {
		return c.String(http.StatusBadRequest, fmt.Sprint("You have a problem in the following fields:", missing))
	}

	c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
	c.Response().WriteHeader(http.StatusOK)

	concurrency.ToGraph(chosenAct, c, internaltypes.SlackMesseger{})

	return nil
}
